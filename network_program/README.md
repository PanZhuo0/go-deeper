##### 极客训练营-GO- 网络通信协议

- OSI七层

```
物理层
数据链路层
网络层
传输层
会话层
表示层
应用层
```

- 工业四层

```
物理数据链路层
网络层
传输层
应用层
```

- 常用的主要协议

```
Socket:接口抽象层，API基本都是基于socket
TCP/UDP：面向连接可靠的/无连接不可靠的
HTTP1.1/HTTP2/QUIC（HTTP3） :超文本传输协议
```

```
HTTP1.1存在的问题:一个连接只能发一个请求，并且需要等待回复
HTTP2.0存在的问题:单连接上如果前面的请求没处理完，后面的请求就会堵住
HTTP3.0 基于UDP协议
```

- socket 抽象层

```
应用程序通常通过 套接字 向网络发送请求或者应答网络请求
面向套接字编程、其提供了一个抽象让编程者不需要考虑底层实际的网络协议

主要的操作
	1.建立、关闭连接
	2.读写、关闭、超时
	3.获取地址、端口
```

- TCP 可靠连接、面向连接的协议

> Attention：需要去了解TCP建立连接和关闭的整个过程

```
TCP/IP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，因为是面向连接的协议

服务端流程：
	监听端口、接受客户端请求建立连接、创建goroutine处理连接
客户端流程：
	建立与服务端的连接、进行数据收发、关闭连接
```

- UDP 不可靠连接，允许广播或者多播

```
UDP 用户数据包协议，是一种无连接的传输层协议

一个简单的传输层协议
	不需要建立连接
	不可靠的、没有时序的通信
	数据报是有长度的 65535-20(首部)=65515
	支持多播和广播
	低延迟、实时性较好
	应用于视频直播、游戏同步等
```

- HTTP超文本传输协议的演进

```
1991 初代HTTP0.9
1996 HTTP1.0
1997 HTTP1.1 
2015 HTTP 2.0 优化了HTTP1.1的性能和安全性
2018 HTTP 3.0 使用UDP代替TCP

HTTP2：
	二进制分帧：按帧的方式传输
	多路复用：代替原本的序列和阻塞机制
	头部压缩：通过HPACK压缩格式
	服务器推送：服务器可以主动推送资源
	
HTTP3：
	连接建立的延时低、一次往返可以建立HTTPS连接
	改进的拥塞控制，高效的重传确定机制
	切换网络保持连接，从4G切换到WIFI不用重建连接
```

##### go网络编程基础

- Go网络编程-基础概念

```
基础概念：
	Socket：数据传输
	Encoding：内容编码
	Session：连接会话状态
		
	C/S模式：通过客户端实现双端通信
	B/S模式：通过浏览器即可完成数据的传输
	
简单的例子：
	通过TCP/UDP实现网络通信
	
网络轮询器：
	多路复用模型
	多路复用模块
	文件描述符
	Goroutine唤醒
```

demo（这个为什么用起来有问题？）

```go
package main

import (
	"bufio"
	"log"
	"net"
)

func main() {
	l, err := net.Listen("tcp", `127.0.0.1:10001`) //指定方式与端口
	if err != nil {
		log.Fatalf("listen err:%v\n", err)
	}
	// 接受并监听
	for {
		// 接受连接
		conn, err := l.Accept()
		if err != nil {
			log.Printf("acppet error:%v\n", err)
			continue
		}
		// 开始监听连接
		go handleConn(conn)
	}
}

func handleConn(conn net.Conn) {
	defer conn.Close()
	// 读写缓冲区
	rd := bufio.NewReader(conn) //reader from connection
	wr := bufio.NewWriter(conn) //writer from connection
	for {
		line, _, err := rd.ReadLine()
		if err != nil {
			log.Printf("read error:%v\n", err)
			return
		}
		wr.WriteString("hello")
		wr.Write(line)
		wr.Flush() //一次性syscall
	}
}

```

- IO模型

```
BIO：blocking IO 阻塞IO
NIO：nonblocking IO 非阻塞IO
IO multiplexing：IO 多路复用
	select
	poll
	epoll
Signal-driven IO：信号驱动式IO
Asynchronous IO:异步IO
```

```
GO采用的是Epoll NIO(非阻塞式的IO)  //2019年时
```

> 推荐：去了解一下select epoll

##### GOIM长连接TCP编程

作者的思路

```
想做一个基于TCP的服务、偏向于IM服务
想做一个聊天室、QQ如何实现的、FACEBOOK的Message的架构、想做长连接这个模块
```

- goim长连接TCP编程-概览

```
comet：长连接管理层、主要是监控外网TCP/websocket端口，
	-- 并且通过设备ID进行绑定channel实现
	-- 以及实现了Room合适直播等大房间消息广播
	
logic:逻辑层，监控连接connect、Disconnect事件，可自定义鉴权、进行记录session信息（设备ID、ServerID、用户		ID），业务可以通过设备ID、用户ID、RoomID、全局广播进行消息推送

job：
	通过消息队列进行推送削峰处理，并把消息推送到对应的Comet节点
	
各个模块之间通过gRPC进行通信
```

```
comet:一种基于HTTP长连接的技术（有状态的层）、IM服务无需在浏览器安装插件也能完成推送消息、
		这导致了一个问题端口不够、可以通过多开几个虚拟网卡，解决端口不够的问题、
		一个网卡65536个开50个就能支持 3000000个长连接了
		以及实现了Room合适直播等大房间消息广播
		
-----------------------------------------------------------------关注分离、comet处理连接、logic实现逻辑


logic：逻辑层（无状态的），监控连接Connect、Disconnect事件，
	可以自定义鉴权、进行记录session消息（设备ID、serverID、用户ID），
		业务可通过设备ID、用户ID、RoomID、全局广播来进行消息推送
		
		-> 由于是无状态的、所以只需要及时重启服务即可
		
session:会话层、保持连接的层、将会话层的状态存储在REDIS中、其中存储的某个用户到Comet的连接关系、有状态、不过保留在redis中的是连接关系、通过心跳机制(长连接)、
	-> 即便redis中的奔溃了，不存在，丢失的连接数量也不会太多

job：
	通过消息队列对消息进行推送削峰处理，并把消息推送到对应comet节点
	-> 如果job出错，重启后只需要将数据发送给对应comet再进行处理即可


因此这个系统整体来说是容灾性很不错，各个层次之间灾难耦合性很低、不担心一层出错，整个服务都run不了
```

其他功能组件

```
redis：用来存储session、保持会话
kafka：用来异步的处理消息、进行消息的削峰
```

![arch.png](https://github.com/Terry-Mao/goim/blob/master/docs/arch.png?raw=true)

- 一些问题

```
1.如何鉴权？
	手写消息协议、然后完成三次握手后需要下一个请求需要立刻发送auth才行
	
2.如何解决连接不够的问题？
	多开几个网卡+修改socket数量限制
```

- 协议的设计

```
PackageLength		4B		包长度		
HeaderLength		2B	头长度
Protocol Version	2B	协议版本
Operation			4B	操作类型
SequenceID			4B	请求序号ID
Body	长度=PackLen-HeaderLen	包的内容
```

```
一些Operation
	Auth		认证
	HeartBeat	心跳
	Message	消息
	....
	
一些sequence
	按请求、响应对应递增的ID
```

```
关于数据发送的时序问题
	-通过sequence 来实现时序的定位
```

```
关于校验码checkSum的问题
	-忘记设计了、没有checkSum可能导致数据被篡改
	-不过这个协议是可以支持扩展的、可以使用checkSum搞定
```

- 边缘节点

```
comet 长连接连续节点，通常部署在距离用户比较近，通过TCP或者websocket建立连接，
	并且通过应用层Heartbeat进行活体检测，保证连接的可用性

节点之间通过云VPC专线通信，按地区部署分布。
	国内：
		华北
		华中
		华南
		华西
    国外
    	香港、日本、美国、欧洲
```

```
PCU：peak concurrent user：峰值并发用户
	PCU几百万、几千万是很恐怖的、对系统要求很高、可以用分布式、解决这个问题、不要单点负载
```

- 负载均衡的实现（wait for）

```
通过分流实现（地区按边缘节点comet进行连接分流，中心节点处理数据）
智能调度、进行服务降级（比如调用更远但更空闲的节点的服务）、比如使用websocket协议/http协议实现而不是自定义协议
```

- 心跳保活机制

```
长连接断开的原因
	长连接所在的进程被杀死
	NAT超时
	网络状态发生变化、比如换网络
	其他不可抗因素
	
高效维持长连接的方案
	进程保活（防止进程被杀死）
	心跳保活（阻止NAT超时）
	断线重连（断网以后重新连接网络）
	
自适应心跳
	心跳可选区间【60-300s】
	心跳增加步长 step=30s
	心跳周期探测，success=current+step  fail=current-step
```

- 如何避免DDOS攻击

```
对于中心城市的BGP机房提供核心服务、应该上高防御性的机房
对于边缘节点，则可以轻松点，因为对外端口很多、不会致使整个服务器DONE、一台服务器几百万
```

- 用户鉴权和session信息

```
用户鉴权，在长连接建立成功后，需要先进行连接鉴权，并且绑定对应的会话信息
总体3个过程
	Connect：建立连接进行鉴权、保存session信息
	Disconncet：断开连接，删除对应session信息
	Session:会话通过Redis保存连接路由信息
```

```
跨机房的session如何同步？
	最好就是一个集中节点实现，要不就采用gossip传播信息给其他节点
	
如果用户不断换IP、不断的换token进行登录攻击如何处理？七层CC（应用层Challenge Collapsar）
```

- 如何处理消息的发送、群发等

```

```

##### GOIM长连接TCP编程-2

- Logic

```
业务逻辑层，处理连接鉴权，消息路由，用户会话管理等
```

- Job

```
进行消息的推送服务，
	对于群发的所有信息，无论ROOM，都发送给Comet，就是广播给Comet而不考虑对应关系，让comet来处理，			如果是用户处于对应的ROOM，comet就会进行响应给用户，如果不是就会丢弃
	
	第二种方案，建立一个路由表，进行点对点发送（暂时没取用）
```

- 推拉组合

```
在长连接中，如果想把消息通知给所有人，
	主要有两种模式，
		一种是自己拿广播通知所有人，也就是“推“模式 		服务端主动广播
		一种是有人主动来找你要，也就是“拉”模式		 服务端被动发送
		
    三种做法
    	推模式
    		有新消息时，服务端主动推送给客户端
    	拉模式
    		由前端主动发起拉取消息的请求
    	推拉结合模式：
    		有新消息实时通知，客户端再进行新消息的摘取（就是发一个小信息提示，用户需要再去获取完整的）
```

```
微信采用的就是推拉结合的关系
```

- 读写扩散

```
一般消息系统中，通常会比较关注消息存储；主要进行考虑 读，写扩散，也就是性能问题；在不同场景，可能选择不同的方式

读扩散，在IM系统里的读扩散通常是每两个相关联的人就有一个信箱，或者每个群有一个信箱
	-优点：写操作很轻量，只要用自己的信箱
	-缺点：读操作很重，需要读所有人的信箱
	
写扩散：每个人都只从自己的信箱里读取数据，但发送消息时，需要想写入所有用户的信箱
	-优点：读操作很轻量
	-缺点：写操作很重，尤其是对于群聊来说
```

```
私聊消息走收件箱、群聊消息走统一的收件箱

比如公众号就更适合读扩散（就是服务端写入一次到它本身的信箱里即可，客户端需要就去读）
```

- 唯一ID的设计-时序ID的问题（时间/顺序ID）

```
唯一ID，需要保证全局唯一性，绝对不会出现重复的ID，且ID整体趋势递增
	雪花ID：
		1bit符号位+41bit时间戳+10bit机器ID+12bit序列号
		
		41bit：毫秒精度的时间戳、理论可用69年（基于设计的start_Time）
		10bit：机器号
		12bit：某个机器在某个时间戳生成的ID的，4096个，也就是允许一个机器在1ms内生成4096个ID且不重复
		
    sonyflake：改进版
    	39bit：10ms作为单位的时间戳，理论可用174年
    	8bit：ID序列号  
    	16bit：机器地址，可以直接用IPV4的低16位地址，所以可以直接用B类私有IP主机号的地址填入即可，简单一点
    	
    	10ms只支持产生128个ID、允许更多的机器65536台服务器，
    	
    基于步长递增的分布式ID生成器，可以生成基于递增，并且比较小的唯一ID；
    	服务主要分为：
    		通过gRPC通信，提供ID生成接口，并且携带业务标记，为不同业务分配ID
    		部署多个id-server服务，通过数据库进行申请ID步长，并且持久化最大的ID，
    		例如，每次批量取1000到内存中，可减少对DB的压力
    		
        数据库记录分配的业务MAX_ID和对应的step，供sequence请求获取
```

- IM私信系统的实现

```
在聊天系统中，有很多用户、消息功能，比如登录、注册、用户信息、可以通过HTTP API方式：消息、群聊、用户状态，可以通过实时通信方式；可能集群一些第三方的服务、比如小米、华为推送、APNs等等

--无状态服务
--有状态服务
--第三方集成
```

```
私聊：
	1对1的聊天,主要的消息发送流程：
		A->B 
		聊天服务从生成器获取消息ID
		聊天服务将消息发送到消息队列
		消费保存在KV存储中
		如果用户在线，则转发消息给用户
		如果用户不在线，则转发通知服务
		
群聊：
	较为复杂，通常由多写、多读两种方式；
	单信箱（多写），每个用户都保存一份消息；
	
	多信箱（多读），每个群仅保存一份消息
		-用户需要同时查询多个信箱
		-如果信箱比较多，查询成本比较高
		-需要控制群组上限
```

